---
title: Next.js 开发指南 冴羽
slug: test-title
tag: Nextjs
---

# 一级标题

## 二级标题

### 三级标题

#### 四级标题

##### 五级标题

###### 六级标题

---

## 2. 文本格式（Text Formatting）

**加粗**

_斜体_

**_加粗+斜体_**

~~删除线~~

<u>下划线（部分 Markdown 编辑器支持）</u>

`行内代码`

---

## 3. 引用（Blockquotes）

> 这是一个引用。
>
> > 嵌套引用。

---

## 4. 列表（Lists）

### 无序列表（Unordered List）

- 项目 1
- 项目 2
  - 子项目 2.1
  - 子项目 2.2
- 项目 3

### 有序列表（Ordered List）

1. 第一项
2. 第二项
   1. 子项 2.1
   2. 子项 2.2
3. 第三项

---

## 5. 代码块（Code Blocks）

### 行内代码（Inline Code）

使用 `console.log('Hello, World!');` 输出内容。

### 代码块（Fenced Code Blocks）

```javascript
function helloWorld() {
  console.log('Hello, World!')
}
```

```python
def hello_world():
    print("Hello, World!")
```

---

## 6. 表格（Tables）

| 姓名 | 年龄 | 城市 |
| ---- | ---- | ---- |
| 小明 | 20   | 北京 |
| 小红 | 22   | 上海 |
| 小刚 | 21   | 广州 |

---

## 7. 链接和图片（Links & Images）

### 链接

[GitHub](https://github.com)

### 图片

![Markdown Logo](https://upload.wikimedia.org/wikipedia/commons/4/48/Markdown-mark.svg)

---

## 8. 任务列表（Task Lists）

- [x] 已完成任务
- [ ] 未完成任务
- [ ] 继续进行中...

---

## 9. 分隔线（Horizontal Rules）

---

---

---

---

## 10. HTML 支持（HTML Support）

<details>
  <summary>点击展开</summary>
  这里是隐藏的内容。
</details>

---

## 11. 特殊字符（Escaping Characters）

\*斜体\*  
\_ 斜体 \_  
\~ 删除线 \~  
\` 代码 \`  
\# 标题 \#  
\- 列表项 \-  
\> 引用 \>

## 路由篇

路由（Router）是 Next.js 应用的重要组成部分。在 Next.js 中，路由决定了一个页面如何渲染或者一个请求该如何返回。

**字体加粗效果**

==高亮效果==

```ts
import { NextResponse } from 'next/server'

export async function GET() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  const data = await res.json()

  return NextResponse.json({ data })
}

// Next.js支持的方法
// route.js
export async function GET(request) {}

export async function HEAD(request) {}

export async function POST(request) {}

export async function PUT(request) {}

export async function DELETE(request) {}

export async function PATCH(request) {}

// 如果 `OPTIONS` 没有定义, Next.js 会自动实现 `OPTIONS`
export async function OPTIONS(request) {}
```

### App Router

```js
src/
└── app
    ├── page.js // 页面index文件 必须有
    ├── layout.js // 布局文件，固定布局，会将page.js渲染到组件中的 children 中
    ├── template.js // 类似layout，但是不会保存状态，如果同级目录有layout会被其包裹
    ├── loading.js // 通用加载文件
    ├── error.js // 通用错误文件
    └── not-found.js // 通用404页面
    ├── about // 路由为 /about
    │   └── page.js
    └── more // 路由为 /more
        └── page.js
```

Next 的路由系统基于文件系统，约定大于配置，定义不同的文件夹就是在给页面定义了不同的路由。

#### 关于 layout 和 template

`layout.tsx` 定义多个页面共享的 UI，会保存状态，除非整个页面刷新，否则只会渲染一次。

`template.tsx` 作用同上，但是不保存状态，每次都重新渲染。

> 说白了，就是类似传统的路由渲染。

```vue
<template>
  <div>layout save state, only render once</div>
  <router-view />
</template>
```

`layout.tsx`，该**组件应该接受**一个`children`的`prop`作为属性，用来渲染页面，类似`router-view`。

关于`template.tsx`，类似于`layout.tsx`，但是不保存状态。如果同级存在`layout.tsx`，那么`template`会放在`layout.tsx` 里面。也就是说 `layout` 会包裹 `template`，`template` 又会包裹 `page`。

**总结**：`layout > template > page`

#### 测试 4 级标题

lroem

##### 测试 5 级标题

lorem

###### 测试 6 级标题

fukc

#### 关于 loading,error,not-found

next 中约定的一些特殊文件，通过名字就知道是在什么时候渲染了，需要手动定义，一般直接在根目录中定义，全局使用。

特别的，想在`layout.tsx`中定义加载动画，需要使用`useEffect`和`useState`。并且需要判断，根据不同的状态，返回包含`html`和`body`的组件。

### 链接与导航

上一节主要讲了如何定义页面，通过文件系统来实现路由，类似`router-view`，而这一节讲解的`Link`则类似与`router-link`。还有一些 hook 函数。顺带讲解一些浏览器原生 api。

#### Link

拓展了原生 a 标签，同样有一个`href`属性，用来指定要去的路由地址。类似：

```tsx
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

并且支持动态渲染。`usePathname` 是一个客户端组件 hook，用于读取当前 URL 的 pathname。

甚至支持 `href` 对象形式的写法。

`<Link href={{ pathname: '/user', query: .... }} />`

#### useRouter() hook

客户端组件，返回一个 router 对象，用于操作路由。在页面中使用，从`next/navigation`中导出，导出位置如果错了问题很大。

<img src="/Users/Lawliet/Library/Application Support/typora-user-images/Screenshot 2024-10-17 at 20.21.16.png" alt="Screenshot 2024-10-17 at 20.21.16" style="zoom:67%;" />

#### redirect 函数

服务端使用，导出位置也是`next/navigation`。

#### History Api

浏览器原生支持的方法。略过。

### 动态路由，路由组，平行路由和拦截路由

#### 动态路由 - 占位参数

假设路由 `http://localhost:3000/about/yeyu/fuck`

- [foldname]
  - 最基本的捕获路由，只能捕获一层即 `yeyu`
- [...foldname]
  - 可以捕获多层路由，即 `yeyu/fuck`
- [[...foldname]]
  - 可以捕获根路由 即 `about/yeyu/fuck`

如果需要得到动态参数，使用`params.foldname`。

> nextjs15 之后返回的是`promise`，需要`await`。

#### 路由组 - 不影响 URL 路径

语法就是使用小括号扩起来，不会再路由中展示出来。`/app/(shop)/layout.tsx`

- 按逻辑分组 -- 开发看代码可能会舒服点
- 创建不同的布局 -- 同级但是被不同的 layout 包裹
- 创建多个根布局 -- 就要手写两个 layout.tsx，里面都要有 html 标签

**注意不要解析为相同的 URL 路径**。

#### 平行路由

`layout.tsx` 中会渲染一个 `page.tsx` 页面，使用平行路由，就可以在`layout.tsx` 中渲染自定义的页面。

使用平行路由可以享受骨架屏的效果。

> 平行路由和路由组一样，不会影响 URL。

定义两个文件夹。

1. `app/@team/page.tsx`
2. `app/@shop/page.tsx`

然后在 `app/layout.tsx`中接收渲染。

```tsx
export function layout({ children, team, shop }) {
  return (
    <div>
      {children}
      {team}
      {analytics}
    </div>
  )
}
```

#### 拦截路由

说白了，就是访问同样地路由地址，通过不同的方式，展示的内容不同。

通过直接 URL 访问，无法拦截，但通过内置链接访问，会被拦截。

同样一个路由地址，通过不同方式访问，却展示了不同的内容。这就是拦截路由的效果。

- `(.)` 表示匹配同一层级
- `(..)` 表示匹配上一层级
- `(..)(..)` 表示匹配上上层级。
- `(...)` 表示匹配根目录

```shell
/user -> 想要拦截user路由
(.)user -> 拦截
```

### 路由处理程序

简单的来说，前后端分离架构中，客户端与服务端之间通过 API 接口来交互。这个“API 接口”在 Next.js 中有个更为正式的称呼，就是路由处理程序。

#### 定义路由处理程序

> 提供后端服务，和`axios`不同，`route`中可以访问数据库。
>
> `axios`调用 API，`route` 提供 API

需要定义在`app`目录下，并且不能和`page.tsx`在同一个文件夹下，文件名必须使用`route.ts`。导出也只能使用命名导出，不能使用默认导出。

```ts
import { NextResponse } from 'next/server'

export async function GET() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  const data = await res.json()

  return NextResponse.json({ data })
}

// Next.js支持的方法
// route.js
export async function GET(request) {}

export async function HEAD(request) {}

export async function POST(request) {}

export async function PUT(request) {}

export async function DELETE(request) {}

export async function PATCH(request) {}

// 如果 `OPTIONS` 没有定义, Next.js 会自动实现 `OPTIONS`
export async function OPTIONS(request) {}
```

### 中间件

> 请求拦截器，类似 Vue3 中的路由导航。

拦截和控制应用里所有的请求和响应。可以在请求处理的早期阶段拦截和修改请求和响应，特别适合在服务器端处理认证、日志记录、重定向等逻辑。

比如，当渲染页面前，可以判断用户是否登陆，如果未登陆则重定向到登陆页面。

在项目根目录定义`middleware.ts`。

#### 匹配路径处理

内置 matcher 匹配

```ts
// middleware.ts
import { NextRequest, NextResponse } from 'next/server'
import { resourceUsage } from 'process'

// 中间件可以是 async 函数，如果使用了 await
export function middleware(request: NextRequest) {
  console.log(JSON.stringify(new URL('/test', request.url)))
  return NextResponse.redirect(new URL('/test', request.url))
}

// 设置匹配路径,当访问 /about或者/about/[] 时，中间件触发
export const config = {
  matcher: '/about/:path*',
}
```

手动条件匹配

```ts
// 如果不使用 matcher 匹配项，也可以在 middleware 函数中使用，慢慢匹配URL...

import { NextResponse } from 'next/server'

export function middleware(request) {
  if (request.nextUrl.pathname.startsWith('/about')) {
    return NextResponse.rewrite(new URL('/about-2', request.url))
  }

  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.rewrite(new URL('/dashboard/user', request.url))
  }
}
```

#### 中间件逻辑

类似 `express` ，读取和设置 `cookie`，读取和设置 `header`，直接响应。

## 渲染篇

### CSR，SSR，SSG，ISR

#### CSR Client-side Rendering

客户端渲染，浏览器会先下载一个非常小的 HTML 文件和所需的 JavaScript 文件。在 JavaScript 中执行发送请求、获取数据、更新 DOM 和渲染页面等操作。

在下载、解析、执行 JavaScript 以及请求数据没有返回前，页面不会完全呈现。

#### SSR client-side Rendering

服务端渲染，在服务端请求接口，获取数据，然后渲染成静态 html 文件，最后返回给客户端 html 文件。

虽然总体速度是更快的，但因为 CSR 响应时只用返回一个很小的 HTML，SSR 响应还要请求接口，渲染 HTML，所以其响应时间会更长，对应到性能指标 TTFB (Time To First Byte)，SSR 更长。

#### SSG Static Site Generation

静态站点生成，在构建阶段，就会将页面编译为静态的 html 文件。

> 比如打开一篇博客文章页面，既然所有人看到的内容都是一样的，没有必要在用户请求页面的时候，服务端再请求接口。干脆先获取数据，提前编译成 HTML 文件，等用户访问的时候，直接返回 HTML 文件。这样速度会更快。再配上 CDN 缓存，速度就更快了。

Next.js 支持 SSG。当不获取数据时，默认使用的就是 SSG。

#### ISR Incremental Static Regeneration

增量静态再生。

还是打开一篇博客文章页面，博客的主体内容也许是不变的，但像比如点赞、收藏这些数据总是在变化的吧。使用 SSG 编译成 HTML 文件后，这些数据就无法准确获取了，那你可能就退而求其次改为 SSR 或者 CSR 了。

考虑到这种情况，Next.js 提出了 ISR。当用户访问了这个页面，第一次依然是老的 HTML 内容，但是 Next.js 同时静态编译成新的 HTML 文件，当你第二次访问或者其他用户访问的时候，就会变成新的 HTML 内容了。

_初始构建_：在你第一次构建应用时，Next.js 会为每个页面生成静态 HTML 文件。这些文件会被存储在服务器上并在用户请求时提供。

_定期更新_：在页面生成后，你可以通过设置一个 **重新验证时间（revalidate time）**，让 Next.js 在每次请求时检查是否需要更新页面。当时间达到设置的 revalidate 值时，Next.js 会在后台请求新的数据，并生成新的 HTML 页面。

_无缝更新_：在后台生成的新页面会被缓存，并在下一个请求时提供给用户。这意味着用户在访问页面时，可能会看到静态内容，但在后台，页面的内容是可以被动态更新的。

### 服务端组件和客户端组件

除非手动声明`use client`，否则组件默认在服务端渲染。

## 数据获取篇

### 数据获取

1. 服务端使用 fetch
2.
